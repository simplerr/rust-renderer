#version 460
#extension GL_EXT_ray_tracing : enable

#include "include/bindless.glsl"
#include "include/view.glsl"
#include "include/atmosphere.glsl"
#include "payload.glsl"
#include "random.glsl"

layout(binding = 0, set = 2) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 2, rgba8) uniform image2D output_image;
layout(binding = 2, set = 2, rgba32f) uniform image2D accumulation_image;

layout(location = 0) rayPayloadEXT Payload rayPayload;
layout(location = 1) rayPayloadEXT Payload shadowRayPayload;

float luminance(vec3 rgb)
{
   // Coefficents from the BT.709 standard
   return dot(rgb, vec3(0.2126f, 0.7152f, 0.0722f));
}

float linearToSrgb(float linearColor)
{
   if (linearColor < 0.0031308f) {
      return linearColor * 12.92f;
   }
   else {
      return 1.055f * float(pow(linearColor, 1.0f / 2.4f)) - 0.055f;
   }
}

vec3 linearToSrgb(vec3 linearColor)
{
   return vec3(linearToSrgb(linearColor.x), linearToSrgb(linearColor.y), linearToSrgb(linearColor.z));
}

// Clever offset_ray function from Ray Tracing Gems chapter 6
// Offsets the ray origin from current position p, along normal n (which must be geometric normal)
// so that no self-intersection can occur.
vec3 offsetRay(const vec3 p, const vec3 n)
{
   const float origin = 1.0f / 32.0f;
   const float float_scale = 1.0f / 65536.0f;
   const float int_scale = 256.0f;

   ivec3 of_i = ivec3(int_scale * n.x, int_scale * n.y, int_scale * n.z);

   vec3 p_i = vec3(
      intBitsToFloat(floatBitsToInt(p.x) + ((p.x < 0) ? -of_i.x : of_i.x)),
      intBitsToFloat(floatBitsToInt(p.y) + ((p.y < 0) ? -of_i.y : of_i.y)),
      intBitsToFloat(floatBitsToInt(p.z) + ((p.z < 0) ? -of_i.z : of_i.z)));

   return vec3(abs(p.x) < origin ? p.x + float_scale * n.x : p_i.x,
      abs(p.y) < origin ? p.y + float_scale * n.y : p_i.y,
      abs(p.z) < origin ? p.z + float_scale * n.z : p_i.z);
}

void main()
{
   uint rngState = gl_LaunchSizeEXT.x * gl_LaunchIDEXT.y + gl_LaunchIDEXT.x;

   // To get different RNG for every sample
   rngState *= view.total_samples;

   vec3 pixelColor = vec3(0.0);

   for (uint s = 0; s < view.samples_per_frame; s++)
   {
      rayPayload.randomSeed = rngState;
      const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(randomFloat(rngState), randomFloat(rngState));
      vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
      inUV.y = 1.0 - inUV.y;
      vec2 d = inUV * 2.0 - 1.0;

      vec4 origin = view.inverse_view * vec4(0,0,0,1);
      vec4 target = view.inverse_projection * vec4(d.x, d.y, 1, 1) ;
      vec4 direction = view.inverse_view * vec4(normalize(target.xyz), 0) ;
      vec3 radiance = vec3(0.0);
      vec3 throughput = vec3(1.0);
  
      for (uint b = 0; b < view.num_bounces; b++)
      {
         float tmin = 0.001;
         float tmax = 10000.0;

         traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
         throughput *= rayPayload.colorDistance.rgb;
         const float hitDistance = rayPayload.colorDistance.w;
         const bool isScattered = bool(rayPayload.scatterDirection.w);

         // Hit sky
         if (hitDistance < 0 || !isScattered)
         {
            radiance += throughput;
            break;
         }

         origin = origin + hitDistance * direction;
         origin.xyz = offsetRay(origin.xyz, rayPayload.normal.xyz);
         direction = vec4(rayPayload.scatterDirection.xyz, 0.0);

#if !SHADOW_RAY
         vec3 light_dir = normalize(view.sun_dir);

         // Directional light
         // Todo: shall use gl_RayFlagsSkipClosestHitShaderEXT and gl_RayFlagsTerminateOnFirstHitEXT
         traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT,
                     0xff, 0, 0, 0, origin.xyz, tmin, light_dir, tmax, 1);
         if (shadowRayPayload.colorDistance.w == -1) {
#if !COLOR_FROM_SUN
            radiance += throughput;
#else
            // Experimentation using color from the sun
            vec3 transmittance;
            vec3 sky_color = IntegrateScattering(origin.xyz, light_dir, 999999999.0f, light_dir, vec3(1.0), transmittance);
            radiance += throughput * min(sky_color, vec3(1.0));
#endif
         }

         // Point light
         // vec3 light_pos = vec3(-7.0, 1.0, 0.0);
         // light_dir = normalize(light_pos - origin.xyz);
         // traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT,
         //             0xff, 0, 0, 0, origin.xyz, tmin, light_dir, tmax, 1);
         // if (shadowRayPayload.colorDistance.w > distance(light_pos, origin.xyz)
         //     || shadowRayPayload.colorDistance.w == -1) {
         //    radiance += throughput;
         // }
#endif
      }

      pixelColor += radiance;
   }

   vec3 accumulatedColor = vec3(0.0);
   if (view.total_samples != view.samples_per_frame)
   {
      accumulatedColor = imageLoad(accumulation_image, ivec2(gl_LaunchIDEXT.xy)).rgb;
   }

   accumulatedColor += pixelColor;

   pixelColor = accumulatedColor / view.total_samples;
   pixelColor = linearToSrgb(pixelColor);

   imageStore(accumulation_image, ivec2(gl_LaunchIDEXT.xy), vec4(accumulatedColor, 0.0));
   imageStore(output_image, ivec2(gl_LaunchIDEXT.xy), vec4(pixelColor, 0.0));
}
