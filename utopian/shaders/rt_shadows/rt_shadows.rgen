#version 460
#extension GL_EXT_ray_tracing : enable

#include "include/bindless.glsl"
#include "include/view.glsl"

layout(set = 2, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout (set = 2, binding = 1) uniform sampler2D in_gbuffer_position;
layout (set = 2, binding = 2) uniform sampler2D in_gbuffer_normal;
layout(set = 2, binding = 3, rgba8) uniform image2D output_image;

layout(location = 0) rayPayloadEXT bool rayPayload;

// Clever offset_ray function from Ray Tracing Gems chapter 6
// Offsets the ray origin from current position p, along normal n (which must be geometric normal)
// so that no self-intersection can occur.
vec3 offsetRay(const vec3 p, const vec3 n)
{
   const float origin = 1.0f / 32.0f;
   const float float_scale = 1.0f / 65536.0f;
   const float int_scale = 256.0f;

   ivec3 of_i = ivec3(int_scale * n.x, int_scale * n.y, int_scale * n.z);

   vec3 p_i = vec3(
      intBitsToFloat(floatBitsToInt(p.x) + ((p.x < 0) ? -of_i.x : of_i.x)),
      intBitsToFloat(floatBitsToInt(p.y) + ((p.y < 0) ? -of_i.y : of_i.y)),
      intBitsToFloat(floatBitsToInt(p.z) + ((p.z < 0) ? -of_i.z : of_i.z)));

   return vec3(abs(p.x) < origin ? p.x + float_scale * n.x : p_i.x,
      abs(p.y) < origin ? p.y + float_scale * n.y : p_i.y,
      abs(p.z) < origin ? p.z + float_scale * n.z : p_i.z);
}

void main()
{
   vec3 pixelColor = vec3(1.0);

   const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy);
   vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);

   vec3 origin = texture(in_gbuffer_position, inUV).xyz;
   vec3 normal = texture(in_gbuffer_normal, inUV).xyz;
   origin.xyz = offsetRay(origin.xyz, normal.xyz);

   vec3 light_dir = normalize(view.sun_dir);

   float tmin = 0.001;
   float tmax = 10000.0;

   rayPayload = true;
   traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT | gl_RayFlagsTerminateOnFirstHitEXT,
               0xff, 0, 0, 0, origin.xyz, tmin, light_dir, tmax, 0);

   if (rayPayload) {
      pixelColor = vec3(0.0);
   }

   imageStore(output_image, ivec2(gl_LaunchIDEXT.xy), vec4(pixelColor, 0.0));
}
